# -*- coding: utf-8 -*-
"""EdgeSense â€” Advanced IoT Edge Agent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o3OR4VeCzokBLLmhDBl_dThg6i_3XQrR
"""

#!/usr/bin/env python3
"""
EdgeSense - advanced IoT edge agent (single-file prototype)
Features:
 - Sensor abstraction with simulated fallback
 - MQTT publishing with TLS option and exponential backoff
 - Local SQLite buffering for offline resilience and guaranteed delivery attempts
 - Minimal local HTTP API (health, last telemetry, force sync)
 - Graceful shutdown
"""

import json
import os
import time
import sys
import threading
import queue
import logging
import sqlite3
import socket
import ssl
import uuid
from http.server import BaseHTTPRequestHandler, HTTPServer
from datetime import datetime, timezone
from typing import Dict, Any, Optional

# Try optional imports
try:
    import paho.mqtt.client as mqtt
except Exception:
    mqtt = None

# Optional hardware libs - if absent, simulation mode works
try:
    import smbus2
except Exception:
    smbus2 = None

# --- Utilities & config loading -------------------------------------------

BASE_DIR = os.path.dirname(os.path.abspath(__file__))

def load_config(path="config.json"):
    if not os.path.exists(path):
        raise FileNotFoundError(f"Config not found: {path}. Copy config.json.example and edit it.")
    with open(path, "r") as f:
        cfg = json.load(f)
    return cfg

def now_iso():
    return datetime.utcnow().replace(tzinfo=timezone.utc).isoformat()

# --- Buffer (SQLite) ------------------------------------------------------

class BufferDB:
    def __init__(self, path):
        self.path = path
        self._init_db()

    def _conn(self):
        return sqlite3.connect(self.path, timeout=30)

    def _init_db(self):
        conn = self._conn()
        try:
            c = conn.cursor()
            c.execute("""
                CREATE TABLE IF NOT EXISTS buffer (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    ts TEXT,
                    topic TEXT,
                    payload TEXT,
                    attempts INTEGER DEFAULT 0
                )
            """)
            conn.commit()
        finally:
            conn.close()

    def add(self, topic, payload):
        conn = self._conn()
        try:
            c = conn.cursor()
            c.execute("INSERT INTO buffer (ts, topic, payload) VALUES (?, ?, ?)",
                      (now_iso(), topic, json.dumps(payload)))
            conn.commit()
        finally:
            conn.close()

    def fetch_batch(self, limit=20):
        conn = self._conn()
        try:
            c = conn.cursor()
            c.execute("SELECT id, topic, payload, attempts FROM buffer ORDER BY id ASC LIMIT ?", (limit,))
            rows = c.fetchall()
            return rows
        finally:
            conn.close()

    def increment_attempt(self, row_id):
        conn = self._conn()
        try:
            c = conn.cursor()
            c.execute("UPDATE buffer SET attempts = attempts + 1 WHERE id = ?", (row_id,))
            conn.commit()
        finally:
            conn.close()

    def delete(self, row_id):
        conn = self._conn()
        try:
            c = conn.cursor()
            c.execute("DELETE FROM buffer WHERE id = ?", (row_id,))
            conn.commit()
        finally:
            conn.close()

    def stats(self):
        conn = self._conn()
        try:
            c = conn.cursor()
            c.execute("SELECT COUNT(*) FROM buffer")
            total = c.fetchone()[0]
            c.execute("SELECT COUNT(*) FROM buffer WHERE attempts > 0")
            attempted = c.fetchone()[0]
            return {"total": total, "attempted": attempted}
        finally:
            conn.close()

# --- Sensor abstraction & simulation -------------------------------------

class SensorBase:
    def read(self) -> Dict[str, Any]:
        """Return a dict with sensor readings and metadata."""
        raise NotImplementedError()

class SimulatedSensor(SensorBase):
    import math, random
    def __init__(self, device_id):
        self.device_id = device_id
        self._t0 = time.time()

    def read(self):
        t = time.time() - self._t0
        temp = 20.0 + 3.0 * self.random.random() + 2.0 * self.math.sin(t / 60.0)
        hum = 40.0 + 10.0 * self.random.random()
        pressure = 1010 + 5 * self.random.random()
        pm25 = max(0.0, 5.0 + 20.0 * self.random.random())
        pir = bool(self.random.random() > 0.95)
        return {
            "timestamp": now_iso(),
            "device_id": self.device_id,
            "temperature_C": round(temp, 2),
            "humidity_pct": round(hum, 2),
            "pressure_hPa": round(pressure, 2),
            "pm2_5": round(pm25, 2),
            "motion": pir
        }

# Placeholder classes for actual sensor drivers
class BME280Sensor(SensorBase):
    def __init__(self, cfg):
        # In a real implementation use smbus2 and a BME280 library
        self.cfg = cfg

    def read(self):
        # TODO: real BME280 read
        return {"timestamp": now_iso(), "device": "bme280", "temperature_C": None}

class DHT22Sensor(SensorBase):
    def __init__(self, cfg):
        self.cfg = cfg

    def read(self):
        # TODO: read DHT22
        return {"timestamp": now_iso(), "device": "dht22", "temperature_C": None}

# --- MQTT Publisher with backoff ----------------------------------------

class MQTTPublisher:
    def __init__(self, cfg, device_id, buffer_db: BufferDB, logger=None):
        self.cfg = cfg
        self.device_id = device_id
        self.buffer = buffer_db
        self.logger = logger or logging.getLogger("MQTTPublisher")
        self.client = None
        self._connected = threading.Event()
        self._stop = threading.Event()
        self._lock = threading.Lock()
        self._setup_client()

    def _setup_client(self):
        if mqtt is None:
            self.logger.warning("paho-mqtt not available; running in no-mqtt mode.")
            return
        self.client = mqtt.Client(client_id=f"{self.device_id}-{uuid.uuid4()}", clean_session=True)
        if self.cfg.get("username"):
            self.client.username_pw_set(self.cfg.get("username"), self.cfg.get("password"))
        tls_cfg = self.cfg.get("tls", {})
        if tls_cfg and tls_cfg.get("enabled"):
            try:
                self.client.tls_set(ca_certs=tls_cfg.get("ca_cert"),
                                    certfile=tls_cfg.get("certfile"),
                                    keyfile=tls_cfg.get("keyfile"),
                                    tls_version=ssl.PROTOCOL_TLS)
                if tls_cfg.get("insecure"):
                    self.client.tls_insecure_set(True)
            except Exception as e:
                self.logger.exception("Failed to configure TLS: %s", e)

        self.client.on_connect = self._on_connect
        self.client.on_disconnect = self._on_disconnect

    def _on_connect(self, client, userdata, flags, rc):
        if rc == 0:
            self.logger.info("Connected to MQTT broker.")
            self._connected.set()
        else:
            self.logger.warning("MQTT connect returned code %s", rc)
            self._connected.clear()

    def _on_disconnect(self, client, userdata, rc):
        self.logger.warning("MQTT disconnected (rc=%s).", rc)
        self._connected.clear()

    def start(self):
        if self.client is None:
            self.logger.info("MQTT disabled (no client).")
            return
        host = self.cfg.get("host", "localhost")
        port = int(self.cfg.get("port", 1883))
        threading.Thread(target=self._run_loop, args=(host, port), daemon=True).start()

    def _run_loop(self, host, port):
        backoff = 1.0
        while not self._stop.is_set():
            try:
                self.logger.info("Connecting to MQTT %s:%d", host, port)
                self.client.connect(host, port, keepalive=60)
                self.client.loop_start()
                # wait until disconnected
                while not self._stop.is_set():
                    time.sleep(1.0)
                    # keep running; on_disconnect will clear event
                break
            except Exception as e:
                self.logger.exception("MQTT connection failed: %s", e)
                self._connected.clear()
                time.sleep(backoff)
                backoff = min(60.0, backoff * 2)
        # cleanup
        if self.client:
            try:
                self.client.loop_stop()
                self.client.disconnect()
            except Exception:
                pass
        self.logger.info("MQTT loop exiting")

    def publish(self, topic_suffix, payload: Dict[str, Any], qos=1, retain=False):
        """
        Publish JSON payload. If unavailable, add to local buffer.
        """
        topic = f"{self.cfg.get('topic_prefix','edgesense')}/{self.device_id}/{topic_suffix}"
        payload_json = json.dumps(payload)
        # If no mqtt client, buffer locally
        if self.client is None:
            self.logger.debug("MQTT disabled: buffering payload.")
            self.buffer.add(topic, payload)
            return False

        # Try live publish with exponential backoff if not connected
        if not self._connected.is_set():
            self.logger.warning("MQTT offline: buffering payload.")
            self.buffer.add(topic, payload)
            return False

        try:
            # publish synchronously and check mid/rc - paho returns a tuple, but is async in various versions
            result = self.client.publish(topic, payload_json, qos=qos, retain=retain)
            # result: MQTTMessageInfo or (rc)
            # If publish had failure, buffer
            if hasattr(result, "rc") and result.rc != 0:
                self.logger.warning("Publish returned rc=%s, buffering", result.rc)
                self.buffer.add(topic, payload)
                return False
            self.logger.info("Published to %s", topic)
            return True
        except Exception as e:
            self.logger.exception("Publish exception: %s. Buffering.", e)
            self.buffer.add(topic, payload)
            return False

    def flush_buffer(self, max_items=50):
        """Attempt to publish buffered items."""
        if self.client is None:
            self.logger.debug("MQTT disabled; cannot flush buffer.")
            return 0
        sent = 0
        rows = self.buffer.fetch_batch(limit=max_items)
        for row_id, topic, payload_json, attempts in rows:
            if not self._connected.is_set():
                self.logger.debug("Not connected; stop flush.")
                break
            payload = json.loads(payload_json)
            try:
                res = self.client.publish(topic, payload_json, qos=1)
                if hasattr(res, "rc") and res.rc != 0:
                    self.logger.warning("Buffered publish rc=%s for id=%s", res.rc, row_id)
                    self.buffer.increment_attempt(row_id)
                else:
                    self.logger.info("Flushed buffered id=%s topic=%s", row_id, topic)
                    self.buffer.delete(row_id)
                    sent += 1
            except Exception as e:
                self.logger.exception("Failed publishing buffered id=%s: %s", row_id, e)
                self.buffer.increment_attempt(row_id)
        return sent

    def stop(self):
        self._stop.set()

# --- Simple HTTP API server -----------------------------------------------

class SimpleAPIHandler(BaseHTTPRequestHandler):
    # these attributes will be set by server init
    svc = None  # EdgeService instance

    def _send(self, code, data, content_type="application/json"):
        self.send_response(code)
        self.send_header("Content-Type", content_type)
        self.end_headers()
        if isinstance(data, (dict, list)):
            self.wfile.write(json.dumps(data, default=str).encode("utf-8"))
        else:
            if isinstance(data, str):
                self.wfile.write(data.encode("utf-8"))
            else:
                self.wfile.write(data)

    def do_GET(self):
        if self.path == "/health":
            self._send(200, {
                "status": "ok" if self.svc.running else "stopped",
                "device_id": self.svc.device_id,
                "version": self.svc.version,
                "last_seen": self.svc.last_telemetry_time
            })
            return
        if self.path == "/last":
            if self.svc.last_telemetry is None:
                self._send(404, {"error": "no telemetry yet"})
            else:
                self._send(200, self.svc.last_telemetry)
            return
        if self.path == "/buffer":
            stats = self.svc.buffer.stats()
            self._send(200, stats)
            return
        self._send(404, {"error": "not found"})

    def do_POST(self):
        if self.path == "/sync":
            # trigger immediate buffer flush (non-blocking)
            threading.Thread(target=self.svc.flush_once, daemon=True).start()
            self._send(202, {"status": "sync started"})
            return
        self._send(404, {"error": "not found"})

    def log_message(self, format, *args):
        # route to logging module
        logging.getLogger("http").info("%s - - %s" % (self.address_string(), format % args))

# --- Edge service: ties all together -------------------------------------

class EdgeService:
    def __init__(self, cfg):
        self.cfg = cfg
        self.device_id = cfg.get("device_id", f"edgesense-{uuid.uuid4()}")
        self.version = cfg.get("version", "0.0.0")
        self.simulate = cfg.get("simulate", True)
        self.publish_interval = int(cfg.get("publish_interval_seconds", 30))
        self.logger = logging.getLogger("EdgeService")
        self.buffer = BufferDB(cfg.get("buffer_db", "edgesense_buffer.db"))
        self.mqtt = MQTTPublisher(cfg.get("mqtt", {}), self.device_id, self.buffer, logger=self.logger)
        self.sensors = []
        self.last_telemetry = None
        self.last_telemetry_time = None
        self.running = False
        self._stop_event = threading.Event()
        # local HTTP API server
        self.http_thread = None
        self.http_server = None

        self._prepare_sensors()

    def _prepare_sensors(self):
        if self.simulate:
            self.logger.info("Simulation mode enabled - adding SimulatedSensor")
            self.sensors.append(SimulatedSensor(self.device_id))
        else:
            s_cfg = self.cfg.get("sensors", {})
            if s_cfg.get("bme280", {}).get("enabled"):
                self.sensors.append(BME280Sensor(s_cfg.get("bme280")))
            if s_cfg.get("dht22", {}).get("enabled"):
                self.sensors.append(DHT22Sensor(s_cfg.get("dht22")))
            # Add more sensor instances here

        if not self.sensors:
            self.logger.warning("No sensors configured; using simulation.")
            self.sensors.append(SimulatedSensor(self.device_id))

    def start(self):
        self.logger.info("Starting EdgeService for device %s (v%s) ...", self.device_id, self.version)
        self.running = True
        # start mqtt thread
        self.mqtt.start()
        # start HTTP server
        self._start_http()
        # start main loop in thread
        self.worker_thread = threading.Thread(target=self._main_loop, daemon=True)
        self.worker_thread.start()

    def _start_http(self):
        bind = self.cfg.get("http_api", {}).get("bind", "0.0.0.0")
        port = int(self.cfg.get("http_api", {}).get("port", 8080))
        SimpleAPIHandler.svc = self
        self.http_server = HTTPServer((bind, port), SimpleAPIHandler)
        self.http_thread = threading.Thread(target=self.http_server.serve_forever, daemon=True)
        self.http_thread.start()
        self.logger.info("HTTP API listening on %s:%d", bind, port)

    def _collect(self):
        # collect from all sensors and merge into single telemetry dict
        merged = {"timestamp": now_iso(), "device_id": self.device_id}
        for s in self.sensors:
            try:
                r = s.read()
                if isinstance(r, dict):
                    # merge keys but avoid overwriting base keys
                    for k, v in r.items():
                        if k not in merged:
                            merged[k] = v
                else:
                    self.logger.debug("sensor returned non-dict: %s", r)
            except Exception:
                self.logger.exception("Sensor read failed")
        return merged

    def _main_loop(self):
        next_pub = time.time()
        # attempt periodic buffer flush every loop
        flush_interval = max(10, int(self.publish_interval / 2))
        last_flush = time.time()
        while not self._stop_event.is_set():
            try:
                now = time.time()
                if now >= next_pub:
                    telemetry = self._collect()
                    self.last_telemetry = telemetry
                    self.last_telemetry_time = telemetry.get("timestamp")
                    # publish / buffer
                    success = self.mqtt.publish("telemetry", telemetry)
                    # Always try to flush some buffer if connected
                    if self.mqtt._connected.is_set():
                        flushed = self.mqtt.flush_buffer(max_items=20)
                        if flushed:
                            self.logger.info("Flushed %d buffered messages", flushed)
                    next_pub = now + self.publish_interval

                # periodic buffer flush
                if now - last_flush > flush_interval:
                    if self.mqtt._connected.is_set():
                        self.mqtt.flush_buffer(max_items=50)
                    last_flush = now

                time.sleep(0.2)
            except Exception:
                self.logger.exception("Error in main loop")
        self.logger.info("Main loop stopping")

    def flush_once(self):
        self.logger.info("Manual flush started")
        flushed = self.mqtt.flush_buffer(max_items=200)
        self.logger.info("Manual flush done, flushed=%d", flushed)
        return flushed

    def stop(self):
        self.logger.info("Stopping EdgeService...")
        self._stop_event.set()
        self.running = False
        # stop http server
        if self.http_server:
            try:
                self.http_server.shutdown()
                self.http_server.server_close()
            except Exception:
                pass
        # stop mqtt
        self.mqtt.stop()
        # wait for worker thread
        if hasattr(self, "worker_thread"):
            self.worker_thread.join(timeout=5)
        self.logger.info("Stopped.")

# --- Main CLI entry -------------------------------------------------------

def setup_logging(level="INFO"):
    numeric = getattr(logging, level.upper(), logging.INFO)
    logging.basicConfig(level=numeric,
                        format="%(asctime)s.%(msecs)03d %(levelname)s [%(name)s] %(message)s",
                        datefmt="%Y-%m-%d %H:%M:%S")
    logging.getLogger("paho").setLevel(logging.WARNING)

def main():
    cfg_path = os.environ.get("EDGESENSE_CONFIG", "config.json")
    cfg = load_config(cfg_path)
    setup_logging(cfg.get("logging", {}).get("level", "INFO"))
    svc = EdgeService(cfg)
    # handle termination
    def handle_sig(signum=None, frame=None):
        svc.stop()
        sys.exit(0)

    try:
        svc.start()
        # block main thread
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        handle_sig()
    except Exception:
        logging.exception("Fatal error")
        handle_sig()

if __name__ == "__main__":
    main()